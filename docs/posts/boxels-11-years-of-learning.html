<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns#">

<head>
    <title>Boxels: 11 Years Of Learning</title>
    <link rel="stylesheet" href="../static/css.css">

    <meta property="og:title" content="Boxels: 11 Years Of Learning" />
    

    <script>
    // Load dark or light mode based on system preference
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.dataset.theme = 'dark';
    }
    else {
        document.documentElement.dataset.theme = 'light';
    }
</script>
    <script src="../static/highlight/highlight.min.js"></script>
<script>
    // Append CSS syntax highlighting theme element to head
    var highlightjs_theme = document.createElement("link");
    highlightjs_theme.rel = "stylesheet";

    if (document.documentElement.dataset.theme == 'dark') {
        highlightjs_theme.href = "../static/highlight/srcery.min.css";
    }
    else {
        highlightjs_theme.href = "../static/highlight/default.min.css";
    }

    document.head.appendChild(highlightjs_theme);
    hljs.highlightAll();
</script>
    <style>
    body {
        padding: 2em;
        background-image: url('https://plus.unsplash.com/premium_photo-1685082778248-d478f0b86512?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1632&q=80');
        background-repeat: no-repeat;
        background-position: center center;
        background-size: cover;
    }

    .wrapper {
        display: flex;
        flex-flow: row wrap;
        text-align: center;
    }

    .wrapper>* {
        padding: 10px;
        flex: 1 100%;
    }

    .header {
        /* background: tomato; */
    }

    .footer {
        /* background: lightgreen; */
    }

    .main {
        /* background: deepskyblue; */
        border-radius: 16px;
        backdrop-filter: blur(100px);
        /* This is so that the body isn't extra padded */
        margin: 0;
        padding: 0;
    }

    .aside-1 {
        /* background: gold; */
    }

    .aside-2 {
        /* background: hotpink; */
    }

    @media all and (min-width: 600px) {
        .aside {
            flex: 1 0 0;
        }
    }

    @media all and (min-width: 800px) {
        .main {
            flex: 3 0px;
        }

        .aside-1 {
            order: 1;
        }

        .main {
            order: 2;
        }

        .aside-2 {
            order: 3;
        }

        .footer {
            order: 4;
        }
    }


    .body-container {
        display: flex;
        flex-direction: column;
    }

    .body-header {
        background-color: lightgray;
        padding: 10px;
        border-top-left-radius: 16px;
        border-top-right-radius: 16px;
        background-color: rgba(0, 0, 0, 0);
    }

    .body-footer {
        background-color: lightgray;
        padding: 10px;
        border-bottom-left-radius: 16px;
        border-bottom-right-radius: 16px;
        background-color: rgba(0, 0, 0, 0);
    }

    .body-content {
        background-color: white;
        flex-grow: 2;
        padding: 10px;
        background-color: lightgray;
        text-align: left;
        background-color: rgba(0, 0, 0, 0);
    }

    code {
        border-radius: 16px;
    }
</style>
    <style>
    @font-face {
        font-family: 'NotoSans';
        src: url('../static/fonts/NotoSans/NotoSans-Regular.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
    }

    @font-face {
        font-family: 'NotoSans';
        src: url('../static/fonts/NotoSans/NotoSans-Italic.ttf') format('truetype');
        font-style: italic;
    }

    @font-face {
        font-family: 'NotoSans';
        src: url('../static/fonts/NotoSans/NotoSans-Bold.ttf') format('truetype');
        font-weight: bold;
    }

    /* Set these one by one for better code styling */
    @font-face {
        font-family: 'NotoSansMono';
        src: url('../static/fonts/NotoSans/NotoSansMono-Regular.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
    }

    @font-face {
        font-family: 'NotoSansMono';
        src: url('../static/fonts/NotoSans/NotoSansMono-Bold.ttf') format('truetype');
        font-weight: bold;
    }

    i {
        font-family: 'NotoSans';
        font-style: italic;
    }

    body {
        font-family: 'NotoSans';
    }

    strong {
        font-family: 'NotoSans';
        font-weight: bold;
    }

    b {
        font-family: 'NotoSans';
        font-weight: bold;
    }

    h {
        font-family: 'NotoSans';
    }

    code {
        font-family: 'NotoSansMono';
    }

    .hljs-keyword, .hljs-built_in {
        font-family: 'NotoSansMono';
        font-weight: bold;
    }
</style>

    <style>
        .header-image {
            /*position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            */
            width: 100%;
            height: auto;
            object-fit: contain;
        }
    </style>
</head>

<body>
    <div class="wrapper">
        <header class="header">
            
        </header>
        <article class="main">
            <div class="body-container">
                <div class="body-header">Header</div>
                <div class="body-content">
                    <h1>Boxels: 11 Years Of Learning</h1>
                    <h3>My Game Programming Journey</h3>
                    <h4><i>2023-07-15</i></h3>

                    <p><img alt="Boxel Screenshot" src="../static/img/boxels-screenshot-3.png" /></p>
<p>It's taken me a lot of personal development to get to the point where I could
even finish something I'd call a "game". Boxels is not that. Other than walking
around, there is nothing to iteract with in the gameworld. Instead, I would
consider this project to be an extensible base upon which to build more
functionality later. For instance, the barebones entity system can be extended
to support picking up items or adding vegetation to the world.</p>
<p>For the longest time I worked on "games" only to the point of seeing something
on screen or achieving a particular technical accomplishment and I would table
the project for later.</p>
<p>I created boxels in 15 day's time working in the evenings and weekends for a
total of approximately 30 hours of work on 12 separate days.</p>
<p>3D audio took me almost an entire day.
Physics took me an entire day.
Networking took me 3 days and I rewrote it 3 times.
I tried 2 different networking techniques to no avail: a
public rendezvous server for NAT Punchthrough and using TCP and UDP together.</p>
<p>Wire protocol vs message protocol.</p>
<p>I rapid prototyped the project using <a href="https://kenney.nl/">Kenny's</a> free assets.
This helped make the beginning of the project more enjoyable as there was
something to render on screen from day one.</p>
<hr />
<p><abbr title="Transmission Control Protocol">TCP</abbr></p>
<pre>
    <div class="mermaid">
        %%{
            init: {
                'logLevel': 'debug',
                'theme': 'default',
                'themeVariables': {
                    'cScale0': '#A0522D',
                    'cScale1': '#8A3324',
                    'cScale2': '#6B8E23',
                    'cScale3': '#8A9A5B',
                    'cScale4': '#9EA587',
                    'cScale5': '#E97451'
                }
            }
        }%%
        timeline
            title Timeline of Project Boxels: Week 1
            Day 1 [7/3/23]: Raylib hello world example up and running
            Day 2 [7/4/23]: Textured boxel model
                : Perspective camera
                : Boxel <-> Entity collisions
                : Walking around in world
            Day 3 [7/5/23]: Billboard sprites
                : Entity <-> Entity collisions
            Day 4 [7/6/23]: Attempted Rendezvous Server for NAT punchthrough
            Day 5 [7/7/23]: Attempted using TCP & UDP together
                : Adopted TCP event transport
                : Added message protocol
                : Multiple players connected
            Day 6 [7/8/23]: Created game object model
                : Moving entities over network
    </div>
</pre>

<pre>
    <div class="mermaid">
        %%{
            init: {
                'logLevel': 'debug',
                'theme': 'default',
                'themeVariables': {
                    'cScale0': '#A0522D',
                    'cScale1': '#8A3324',
                    'cScale2': '#6B8E23',
                    'cScale3': '#8A9A5B',
                    'cScale4': '#9EA587',
                    'cScale5': '#E97451'
                }
            }
        }%%
        timeline
            title Timeline of Project Boxels: Week 2
            Day 7 [7/9/23]: Players see each other
            Day 8 [7/11/23]: Created stoppable asynchronous Task system
            Day 9 [7/12/23]: 3D audio concept
                : Gamepad input
                : Rewrote networking to use task system
            Day 10 [7/13/23]: Player name labels
                : Clients receive map with 6-sided boxels
                : 3D audio complete
            Day 11 [7/14/23]: Networked physics with FCL
            Day 12 [7/15/23]: Non-player entities
                : Created test map with AI generated textures
                : Generated final build using Nuitka
    </div>
</pre>

<ul>
<li>Python, Raylib, and a bunch of other libraries</li>
<li>From-scratch TCP socket networking</li>
<li>By-hand 3D audio</li>
<li>ChatGPT as a coding assitant (both more and less useful than people think)
    Took me all of my 11 years of practice and an AI assistant to do this in 13
    days.</li>
<li>Python's dynamic typing was really difficult when the project got larger.
    I couldn't believe the sensation. It was as if as soon as the project got to
    be slightly larger than I could hold in my brain, I literally felt something
    fall out of my working memory and I had to go and find what it was and get
    it back in there.</li>
</ul>
<hr />
<p>There is no cross-platform way to get the MTU in any language!</p>
<hr />
<p><img alt="Boxel Screenshot" src="../static/img/boxels-screenshot-2.png" /></p>
<p>Boxels refer to a nomenclature I have developed over the years:</p>
<ul>
<li>Pixels: containers for a specific color in a 2D image</li>
<li>Voxels: volumetric data</li>
<li>Bloxels: isometric 2.5D voxel sprites</li>
<li>Boxels: textured cubes large enough for one game entity to stand in</li>
</ul>
<p>Libraries Used:</p>
<ul>
<li>Raylib (windowing, rendering, input, audio, timing)</li>
<li>Flexible Collision Library (collision detection &amp; response)</li>
<li>Pydantic (marshalling events back and forth)</li>
<li>MessagePack (compressing events back and forth)</li>
<li>MeowHash Python (bindings to MeowHash written by me)</li>
<li>Nuitka (compiling the game to an executable)</li>
</ul>
<p>The design of the game involved a client that handles player input, sound,
resource loading, and graphics, and a server that would handle the gameworld
simulation with physics, player -&gt; entity tracking, and map generation.</p>
<p>TODO(pbz): Create mermaid diagrams for this stuff.</p>
<p>Asynchrony was harnessed through the creation of a stoppable task type that took
advantage of Python generators to yield at key stopping points in the thread
handler function. Cleanup code could then examine which checkpoint was last
yielded to see what resources needed to be freed. The server transport, client
handler, and client transport all used the task type in order to run code in a
separate thread. All the usual Python threading caveats apply, although a useful
feature of the task class was a built in way to send and receive messages from
outside and inside the task. This provided a very flexible base upon which to
build complex raw socket handling code while utilizing Python's ability to get
parallelism with IO tasks.</p>
<p>TODO(pbz): Create mermaid diagrams for this stuff.</p>
<p>Both the client and the server made use of a custom networking facility that
used raw TCP sockets. To send structured data back and forth, an event/messaging
model was created by using Pydantic models serialized to JSON and encoded with
MessagePack which greatly reduced their size. Events were effectively type
checked as constructing one with incorrect data types was impossible using
Pydantic.</p>
<p><img alt="Boxel Screenshot" src="../static/img/boxels-screenshot-1.png" /></p>
<p>TODO(pbz): Create mermaid diagrams for this stuff.</p>
<p>Events also took advantage of the mixin class design pattern by inheriting from
a quick update type that would demarcate that event as eligible for
deduplication in situations where the network was unable to keep up with the
amount of those events being sent. This worked extremely well and made it so
that only one player input or entity update event was ever sent over the wire.
Since the events already used Pydantic, adding a new event type was as simple
as inheriting one or two classes and adding annotated fields.</p>
<p>TODO(pbz): Create mermaid diagrams for this stuff.</p>
<p>The game object model was maintained by the server and mirrored on the client.
Modifications to the model during runtime were communicated via one-shot or
frame-by-frame events. The map was only update upon modification and the current
position of entities and connected players was sent every frame. The object
model was simple in that there were only ever 3 types, one for the player,
entities, and boxels. More types would have eventually been needed to structure
and store more data, however, as dictionaries formed the backbone of the client
and server's game object storage.</p>
<p>TODO(pbz): Create mermaid diagrams for this stuff.</p>
<p>On the server, connections were tracked by address and handled in their own
task.</p>
<p>The client</p>
<p>The server</p>
<p>Object Model
Data Model</p>
<p>Graphics were rendered using Raylib</p>
<p>Input was gathered using Raylib. Gamepad input was extremely easy to obtain and
manage.</p>
<p>The 3D boxels themselves were loaded from a mesh created in Blender containing
6 quads made of 2 coplanar triangles, each with UV coordinates mapped to a
spritesheet laid out with room for 6 textures along the X axis. The boxel model
was loaded once but then each unique combination of boxel side textures was
drawn to an image and uploaded to the GPU for use during rendering. In this way,
boxels using the same texture could be batched by Raylib and there was ever only
1 mesh in play aside from the quads submitted by Raylib for billboard sprites,
fonts, and debug geometry. When drawn to an image during runtime, they would
look like this:</p>
<p><img alt="Boxel Texture" src="../static/img/boxel-texture.png" /></p>
<p><img alt="Boxel Texture Annotated" src="../static/img/boxel-texture-annotated.png" /></p>
<p>Specifying side textures to cache used these combinations:</p>
<ul>
<li>All sides</li>
<li>Top, rest of sides</li>
<li>Top, bottom, rest of sides</li>
<li>Top, bottom, left, right, front, back</li>
</ul>
                </div>
                <div class="body-footer">
                    <style>
    .rss-icon {
        width: 24px;
        height: 24px;
        color: #000;
    }
</style>

<a href="../static/rss.xml">
    <svg class="rss-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 11a9 9 0 0 1 9 9"></path>
        <path d="M4 4a16 16 0 0 1 16 16"></path>
        <circle cx="5" cy="19" r="1"></circle>
    </svg>
</a>
                </div>
            </div>

        </article>
        <aside class="aside aside-1"></aside>
        <aside class="aside aside-2"></aside>
        <footer class="footer"></footer>
    </div>


    <!-- Comments do not load locally -->
    <!-- Utterances GitHub Issue Comments -->
<script src="https://utteranc.es/client.js"
    repo="pebaz/fromzero-blog"
    issue-term="og:title"
    label="comment"
    theme="preferred-color-scheme"
    crossorigin="anonymous"
    async>
</script>

    <script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script>
    kofiWidgetOverlay.draw('pebaz', {
        'type': 'floating-chat',
        'floating-chat.donateButton.text': 'Support me',
        'floating-chat.donateButton.background-color': '#00b9fe',
        'floating-chat.donateButton.text-color': '#fff'
    });
</script>

    <script src="../static/js/mermaid.js"></script>
<script>
    function initializeMermaid()
    {
        mermaid.initialize({startOnLoad: true})
    }

    if (
        document.readyState === "complete" ||
        document.readyState === "interactive"
    ) {
        setTimeout(initializeMermaid, 1);
    }
    else
    {
        document.addEventListener("DOMContentLoaded", initializeMermaid);
    }
</script>
</body>

</html>